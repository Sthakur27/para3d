import java.lang.Math;
import java.util.*;
public class parse{ 
    static String exp;
    private static String type1="E0123456789.ep";
    private static String type2="+-*/^";
    private static String type3="()";
    private static String type4="cossintanlogcoshsinh"; //cos  sin tan log
    private static String all="E0123456789.ep+-*/^cossintanlogcoshsinhuv()xyz";
    private static String vars="xyzuv";
    private static ArrayList<pObj> pobs=new ArrayList<>();
    static ArrayList<Double> xreturnlist=new ArrayList<>();
    static ArrayList<Double> yreturnlist=new ArrayList<>();
    static ArrayList<Double> zreturnlist=new ArrayList<>();
    static boolean pointexists=true;
    static boolean invalid=false;
    static String xstring;
    static String ystring;
    static String zstring;
    
    /* parses 3 string expressions(x=,y=,z=) over two parametric values (u and v) from 
    ustart to uend  and vstart to vend with numofsteps subintervals
    Also modifies validpoints arraylist to mark nonexistant points as invalid (ex. log(-4))
    */
    public static void parainterp(String str1, String str2, String str3, double ustart, double uend,double vstart, double vend, double numofsteps,ArrayList<Boolean> validpoints){
        invalid=false;
        xstring=str1; ystring=str2; zstring=str3;
        //evaluates every string and fills values in corresponding returnlist.  to access the list use parse.xreturnlist etc
        validpoints.clear();
        //sets all points to valid but during evaluation will correct if invalid
        for(int i=0;i<(numofsteps+1)*(numofsteps+1);i++){
            validpoints.add(true);
        }
        String[] strings={str1,str2,str3};
        //put a "*" in front of variables that don't have operand in front of them.
        for(int j=0;j<strings.length;j++){
           if(strings[j].length()>1){
             for(int i=1;i<strings[j].length();i++){
                //if before var there is a var or a number add a '*'
                if((vars.indexOf(strings[j].substring(i-1,i))!=-1 || type1.indexOf(strings[j].substring(i-1,i))!=-1) && vars.indexOf(strings[j].substring(i,i+1))!=-1){
                    strings[j]=strings[j].substring(0,i)+"*"+strings[j].substring(i);
                }
             }    
           }
        }
        //replace x,y,z in other strings with the x,y and z expressions
        for(int j=0;j<strings.length;j++){
          for(int i=0;i<strings.length;i++){
              strings[j]=strings[j].replaceAll("x",xstring);
              strings[j]=strings[j].replaceAll("y",ystring);
              strings[j]=strings[j].replaceAll("z",zstring);
          }
        }
        //System.out.print(strings[0]+"\n"+strings[1]+"\n"+strings[2]);
        xreturnlist.clear();
        yreturnlist.clear();
        zreturnlist.clear();
        interpoverrange(xreturnlist,strings[0],ustart,uend,vstart,vend,(uend-ustart)/numofsteps,(vend-vstart)/numofsteps,validpoints);
        interpoverrange(yreturnlist,strings[1],ustart,uend,vstart,vend,(uend-ustart)/numofsteps,(vend-vstart)/numofsteps,validpoints);
        interpoverrange(zreturnlist,strings[2],ustart,uend,vstart,vend,(uend-ustart)/numofsteps,(vend-vstart)/numofsteps,validpoints);
        if(invalid){
           for(ArrayList<Double> list:new ArrayList[]{xreturnlist,yreturnlist,zreturnlist}){
               for(int i=0;i<list.size();i++){
                  list.set(i,new Double(0.0));
               }
           }
        }
    }
    
    
    
    /*
       sub method of parainterp which fills a list with values generated by parsed string expression
       over u and v parameters with their respective starts, ends, and subinterval lengths
    */
    public static void interpoverrange(ArrayList<Double> list,String str, double ustart, double uend, double vstart, double vend, double ustep,double vstep,ArrayList<Boolean> validpoints){
      //first check if string is valid:
      int poscounter=0;
      boolean valid=true;
      for(int m=0;m<str.length();m++){
        //check for unrecognized characters
         if(all.indexOf(str.substring(m,m+1))==-1){
              valid=false;System.out.println(str+" has unrecognized characters: "+str.substring(m,m+1));
              invalid=true;
         }
      }
      //check for unmatched paranethesis
      int parencount=0;
      for(int n=0;n<str.length();n++){
        //check for unrecognized characters
         if(str.substring(n,n+1).equals("(")){parencount++;} if(str.substring(n,n+1).equals(")")){parencount--;}
      }
      if(parencount!=0){
           valid=false; System.out.println(str+" has not enough parenthesis");  invalid=true;
      }
      
      if(valid && !str.equals("")){
         //for every u val        
        for(double u=ustart;u<=(uend+(ustep/2));u+=ustep){
            //for every v value on interval
            for (double v=vstart;v<=vend+(vstep/2); v+=vstep){ 
                 exp=str.replaceAll("u","("+Double.toString(u)+")");
                 exp=exp.replaceAll("v","("+Double.toString(v)+")");
                 //System.out.println(exp);
                 classify();
                 //does full eval  and if point doesn't exist appends it to asymptote list
                 if(!fulleval()){validpoints.set(poscounter,false); 
                 }
                 double answer=pobs.get(0).num;
                 pobs.clear();
                 list.add(answer);        
                 poscounter++;
            }
          } 
        //double check last point for validity
      }
      else{
         for(double u=ustart;u<=(uend+(ustep/2));u+=ustep){
            for (double v=vstart;v<=vend+(vstep/2); v+=vstep){
                 list.add(0.0);}}
      }
    }
    
    
    
    
    //interprets and parses a string with no variables.  ex "4-3^0.02"
    public static double interp(String str){
        if(str.equals("")){return(0);}
        exp=str;
        classify();
        fulleval();
        double temp=pobs.get(0).num;
        pobs.clear();
        return(temp);
    }
    
    
    
    //classifies a the string exp into an arraylist of pObj's to use for evaluation
    public static void classify(){
        try{
            int numlength=0;
            for(int i=0;i<exp.length();i++){
                if (type1.indexOf(exp.substring(i,i+1))!=-1){
                   numlength=i;
                   while(numlength+1<exp.length() && type1.indexOf(exp.substring(numlength+1,numlength+2))!=-1){   
                       if(exp.substring(numlength+1,numlength+2).equals("E")){numlength+=1;}
                       numlength+=1;
                   }
                   pobs.add(new pObj(0,exp.substring(i,numlength+1)));
                   i=numlength;
                }
                else if(type2.indexOf(exp.substring(i,i+1))!=-1){
                   pobs.add(new pObj(1,exp.substring(i,i+1)));
                }
                else if(type3.indexOf(exp.substring(i,i+1))!=-1){
                   pobs.add(new pObj(2,exp.substring(i,i+1)));
                }
                //sinh cosh
                else if(type4.indexOf(exp.substring(i,i+4))!=-1){
                   pobs.add(new pObj(3,exp.substring(i,i+4)));
                   i+=3;
                }
                //sin tan cos log
                else if(type4.indexOf(exp.substring(i,i+3))!=-1){
                   pobs.add(new pObj(3,exp.substring(i,i+3)));
                   i+=2;
                }
                else if(exp.substring(i,i+1).equals("E")){
                   //System.out.println("ok");
                   pobs.add(new pObj(2,"*"));pobs.add(new pObj(1,"10")); pobs.add(new pObj(2,"^"));
                }
                else{pobs.add(new pObj(0,"0.0"));}
            }
        }
        catch(StringIndexOutOfBoundsException e){
           invalid=true;
           pobs.add(new pObj(0,"0.0")); 
        }
    }
    
    
    
    
    //check if parenthesis exists
    public static boolean paren(){
        for (pObj a:pobs){
            if (a.mode==2){return true;}
        }
        return false;
    }
    
    
    
    
    //evaluates the full pObj list
    public static boolean fulleval(){
      pointexists=true;
        int left=0;
        while(paren()){
            for (int j=0;j<pobs.size();j++){
                if (pobs.get(j).oper.equals("(")){
                    left=j;
                }
                if(pobs.get(j).oper.equals(")")){
                    eval(left+1,j-1);
                    pobs.remove(left+2);
                    pobs.remove(left);
                    break;
                }
            }
        }   
        //now the parenthesis are all gone
        eval(0,pobs.size()-1);
        if(!pointexists){pobs.get(0).num=0;}
        return(pointexists);
    }
    
    
    
    
    //submethod of fulleval which can evaluate a sublist of pObj's which doesn't contain paranethesis
    //startpos is  after (  and endpos is before )
    public static void eval(int startpos,int endpos){
      for(int prior=4;prior>=1;prior=prior-1){
         for(int i=startpos;i<endpos;i++){
            if(pobs.get(i).priority==prior){
              int numofremovals=operate(pobs,i);              
              for (int j=0;j<numofremovals;j++){                
                  pobs.remove(i);
              }
              i-=1; endpos-=numofremovals;             
            }              
         }
      }
    }
    
    
    
    
    //operates pObj list for different functions ex.('-', 'sin', 'cos', etc)
    public static int operate(ArrayList<pObj> list, int i){
        try{
              if(pobs.get(i).mode==1){
                 if(list.get(i).opernum==1){list.get(i-1).num=list.get(i-1).num+list.get(i+1).num;      }
                 else if(list.get(i).opernum==2){
                       if(i==0||list.get(i-1).mode!=0){
                           list.get(i+1).num*=-1; return(1);
                       }
                       else{list.get(i-1).num=list.get(i-1).num-list.get(i+1).num; }}
                 else if(list.get(i).opernum==3){list.get(i-1).num=list.get(i-1).num*list.get(i+1).num;  }
                 else if(list.get(i).opernum==4){list.get(i-1).num=list.get(i-1).num/list.get(i+1).num;  }
                 else if(list.get(i).opernum==5){list.get(i-1).num=Math.pow(list.get(i-1).num,list.get(i+1).num);  }
                 return(2);
              }
              else if(pobs.get(i).mode==3){
                 if(list.get(i).opernum==6){list.get(i+1).num=Math.sin(list.get(i+1).num); }
                 else if(list.get(i).opernum==7){list.get(i+1).num=Math.cos(list.get(i+1).num); }
                 else if(list.get(i).opernum==8){list.get(i+1).num=Math.tan(list.get(i+1).num); }
                 //check for logs<=0
                 else if(list.get(i).opernum==9){
                     if(list.get(i+1).num>0){
                     list.get(i+1).num=Math.log(list.get(i+1).num); }
                     else{list.get(i+1).num=0; pointexists=false;}
                 }
                 else if(list.get(i).opernum==10){list.get(i+1).num=Math.sinh(list.get(i+1).num); }
                 else if(list.get(i).opernum==11){list.get(i+1).num=Math.cosh(list.get(i+1).num); }
                 return(1);
              }
              return(0);
        }
        catch(Error e){
           invalid=true;
           return(0);
        }
    }
    
    
    
    
    //prints the contents of the pObj list. Only for debugging use.
    public static void print(){
       for (int i=0;i<pobs.size();i++){
          System.out.print("["+i+"]"+"   "+pobs.get(i)+", ");
       }
       System.out.println("");
    }
}